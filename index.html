<!DOCTYPE html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Scrolls</title>
	<link rel="shortcut icon" href="lib/favicon.png" type="image/x-icon">
	<link rel="icon" href="lib/favicon.png" type="image/x-icon">

	<link rel="stylesheet" type="text/css" href="lib/bootstrap.min.css">

	<link rel="stylesheet" type="text/css" href="css/styles.css">
	<link rel="stylesheet" type="text/css" href="css/tombstone-stack-component.css">
	<link rel="stylesheet" type="text/css" href="css/message-block-component.css">
	<link rel="stylesheet" type="text/css" href="css/message-stream-component.css">
	<link rel="stylesheet" type="text/css" href="css/animated-message-component.css">
</head>
<body>
	<main>
		<section class="container-fluid write-up">
			<header class="row">
				<div class="section-block col-lg-8 col-10 offset-1 offset-lg-2">
					<h1>Scrolls: Unraveled</h1>
					<aside class="row example-row intro-paragraph">

						<figure class="image gif scrolling-gif col-lg-6 col-md-6 col-sm-12">
							<img src="images/scroll-forever.gif" alt="Zombie Scrolling">
						</figure>

						<p class="col-lg-6 col-md-6 col-sm-12">We scroll—a lot; at it's root, the motion is no far cry from the impulses of countless, so un-questionably human expressions of leisure and habit. But, where idle hands fall to the devil, and in so-doing lead to fidgeting of unproductive sorts, there is hope in making the sweet sensation of content scrolling, well, sweeter.</p>

					</aside>

					<p>Documents grow, shrink, and mutate in ways far more engaging than what was likely ever conceived for early <i>web-browsing</i>. In modern spirit, we need not be afraid of getting a bit exotic with the way we present classic constructs in our web-pages.</p>

					<aside class="row example-row intro-paragraph">

						<figure class="image gif youtube-gif col-lg-6 col-md-6 push-md-6 col-sm-12">
							<img src="images/youtube.gif" alt="YouTube Chat">
							<figcaption class="text-center"><i>YouTube Live Chat Stream</i></figcaption>
						</figure>

						<div class="col-lg-6 col-md-6 pull-md-6 col-sm-12">
							<p>So long as we use current web tools, manipulating DOM nodes to present content for users, we are responsible for making the experience as seamless as hardware allows. As for content, let's take the humble list; a collection of items with content, calls to action, and expected gestures belonging to each item is easy enough to create, show, manipulate and so on.

							<p>We throw as many elements at our document as we need. That's fine, plenty of pages on the web append elements indefinitely. Realistically, most users never actually stick around long enough for thousands of items to update, or those thousands of items never do much in terms of user-interaction. In most of these cases, the requirement is minimal, so we don't usually have to worry about performance.</p>
						</div>

					</aside>

					<p>We rely on the metal in to which we throw our programs to churn through however many steps be required, only to care for the final result. That's fine, it's exactly what pen and paper does for a busy mind, and exactly what a computer is ought to be doing whilst it shepherds our data on the digital frontier. But, as we get ever-closer to squeezing the last drop from silicon, we ought not rely on sheer force, or scale, to solve problems that can otherwise be framed alternatively—achieving the same, if not better, result along the way.</p>

					<h3>Growing Pains</h3>

					<aside class="row example-row intro-paragraph">

						<figure class="image gif scrolling-gif col-lg-6 col-md-6 push-md-6 col-sm-12">
							<img src="images/zombie-scroll.gif" alt="Zombie Scrolling">
						</figure>

						<div class="col-lg-6 col-md-6 pull-md-6 col-sm-12">
							<p>There is quite a bit of literature on the topic of scrolling, content absorption, action-reward mechanisms. Most of it attacks, quite rightly, the psychological and physiological effects of ever-enticing scrolling experiences. For those interested in the effectiveness of such sorcery, plenty can be found on—yes, the Internet! I'd like to avoid fixing that problem in this exercise. Although it's a valiant fight for keeping one's mind at peace, it's oft a fight each must lead with a firm will in this noisy world.</p>

							<p>That said, fear not, as we are not writing refined programs, only to find they will enslave ourselves with their might! For now, we can embrace the computers we are teaching, and firmly believe their rigid abiding nature will alleviate more inconvenience than they create trouble.</p>
						</div>

					</aside>

					<h3>In the Now!</h3>
					<aside class="row example-row intro-paragraph">

						<figure class="image col-lg-6 col-md-6 col-sm-12">
							<span class="live-tag">Live</span>
							<img src="images/welles.jpg" alt="Welles Radio">
							<figcaption class="text-center"><i>Orson Welles: Live Broadcast of "War of the Worlds"</i></figcaption>
						</figure>

						<div class="col-md-6 col-12">
							<p>What about live feeds? The likes of YouTube, Facebook, Twitch, and others have taken to showcasing and engaging their users with live content in form of comment, vote, and reaction streams. The word, the little red dot, the somewhat tense feeling about this state-of-being invokes a sense of fleeting <i>now-ness</i> that many of us enjoy, hate, or otherwise find stimulating. We find it's analogues  in 'On-Air' signs, radio/television broadcasts, newspapers, and in so many other spoken and written forms. The euphoric feeling seems to come from actually seeing interaction—streams of dialogue, messages and comments whizzing through digital, metaphorical, or actual windows.</p>
						</div>

					</aside>

					<p>With each historical step towards presenting content, the delivery-method must be made equally pleasant! Live radio and television have been refined to wonderful levels of engagement for the audience they seek to inform; in similar fashion, our web application must make this effort anywhere we can justify it's efficacy.</p>

					<p>Where the visual/auditory sensation of content-consumption seems most-rewarding, we should be thinking about making that delivery as fluid and natural as possible. Easing looks better than abrupt stops in animation because that's how most things work in real-life. This topic comes up a lot in physical mechanics, architecture, where actual things behave according to natural laws. More on the <a href="https://www.wired.com/2016/07/everything-harmonic-oscillator/" target="blank"><i>Everything is a Spring</i></a> topic can be found in plenty of articles on the Internet.<span class="alert">Disclaimer: a little bit of math and physics follow down that rabbit hole, but it's a really interesting topic.</span></p>

					<p>The reason any of the math or physics involved in describing physical systems, is that we're replicating one in our browser. The window, viewport, or whatever we want to call it, displays list items. If we are to engage with this list in any way, it <i>should</i> behave the way, say, some wood blocks (messages) on an actual desktop (viewport) would move about the desktop's surface.</p>

					<p>If we begin to display our messages with hesitation, the illusion of a physical system is lost, and we reveal the jagged edges of our simulation. It may seem trivial, a miniscule metric that even the user may fail to articulate meaningfully, but it does accumulate—the sour feeling from delayed, jagged, or slow-responding transitions are noticed. The way something <i> feels </i> goes quite a bit further for a useful system than just aesthetics. This, again, is worth thinking about, just not in this scope.

					<p>Simply put, if our hardware cannot smoothly show an endless list of elements efficiently and consistently, we can attempt to re-frame the problem—hopefully without the never-ending list of DOM elements.</p>
				</div>
			</header>
			<article class="row">
				<section class="section-block col-lg-8 col-10 offset-1 offset-lg-2">
					<h2>A Long List need not actually be Long</h2>

					<aside class="row example-row">

						<p class="col-md-6 col-12">When we think of a long document with countless items, nodes, etc., it is impossible to ignore the repetition in form—and, it's absence in content. The contents of a list, generally, are unique—which is why we are moved to collect, compare, and differentiate between one or another item. To reign in the scope a bit, let's tackle the seemingly infinite list of comments we can surely find at the bottom, side, or front-and-center of a web application. Most everywhere I've looked, a comment appears, moves the rest out of the way, and the list goes on. Technically, it's merely adding, removing nodes to/from the relevant parent node. Although we can simply add and remove nodes, we can also do better.</p>

						<figure class="image gif long-list-gif col-lg-6 col-md-6 col-sm-12">
							<img src="images/long-list.gif" alt="Long List">
							<figcaption class="text-center"><i>Overwhelmingly Long List</i></figcaption>
						</figure>
					</aside>

					<p> Let's look at what makes and characterizes a list on a webpage:</p>
					<ul>
						<li>One or more elements with meaningful content inside</li>
						<li>Organized or ordered by one or more rules (time, alphabet, popularity, importance)</li>
						<li>There are only so many elements we can display in a viewport to say they're relevant, legible, or otherwise meaningful in some way to the reader.</li>
						<li>Scrolling up and down a list feels natural; a element's position on screen, relative to others, is generally fixed and unchanging—which is to say that we care about an element's persistence throughout the document.</li>
						<li>The browser window, or container of our elements usually takes care of hiding/showing elements—we need only supply elements.</li>
					</ul>
					<aside class="row example-row">

						<div class="message-animation col-lg-2 offset-lg-2 col-md-2 offset-md-2 col-sm-6 offset-sm-3 col-6 offset-3" data-direction="scroll"></div>
						<div class="col-lg-6 offset-lg-2 col-md-6 offset-md-1 col-12">
							<p>We can infer from the last point, that we never need what we don't see in the viewport, which means we can ignore those nodes entirely, as we scroll down the page. Ignoring nodes, usually means relying on the viewport to obscure them from the current scroll position. This is brilliantly simple, but it's a mechanism we take for-granted.</p>

							<p>When we consider performance for a long list, the amount of nodes in the document becomes the apparent bottleneck. Sure, the browser obscures those nodes just fine, but they are still written to memory, they are still there, and they <i>will</i> affect rendering of new ones when there are enough existing elements in the DOM. So, if we reduce the amount of nodes, and not rely on the viewport to hide/show elements, the burden shifts to the program.</p>

						</div>

					</aside>

					<p>There is a cost to playing the magician if we are to not rely on the viewport to show/hide elements when we need them for any given scroll position. The more we explore alternative ways of maintaining a long-document illusion, the more we must think about nuanced positioning for which we are now responsible.</p>

					<p>Perhaps that effort exceeds the savings in drawing hundreds of DOM nodes in a message stream. However, this exercise seeks to stretch the imagination a bit, and—perhaps it can lead to other interesting solutions for experiences with the ever-growing lists we now consume.</p>
				</section>
				<section class="section-block col-lg-8 col-10 offset-1 offset-lg-2">
					<h2>DOM Elements Dance</h2>
					<aside class="row example-row">
						<div class="col-lg-4 offset-lg-2 push-lg-6 col-md-6 offset-md-3 col-sm-6 offset-sm-3 col-7 offset-4 message-block" data-count="1"></div>
						<div class="col col-lg-6 pull-lg-6 col-md-12 col-12">
							<p>If we say a message must contain an image (or a tombstone avatar,) date, user name, and some padding/margin, we can assume each node will be some known height in pixels.</p>

							 <p>For any modern screen, even in portrait mode we care only to the extent of a fullscreen run at a practical limit of 3440px.</p>

							<p>Luckily, most mobile devices fall far short of this upper-bound. So, even at that resolution and scaling, <code>3440 / 150</code> gives us <code>~20</code> nodes. Taking in to account margins between each node, we need even less nodes to fill the viewport.</p>

							<p>We'll be <i>extra</i> safe, and, for sake of implementation bump that to 30, which gives us three even groups of ten and makes for some easier transforms later.</p>

							<p>We now have thirty nodes, we've scrolled to the bottom of the doc, what do we do? Add more! Well, sort of.</p>
						</div>
					</aside>

					<aside class="row example-row">
						<div class="message-animation col-lg-2 offset-lg-2 col-md-2 offset-md-2 col-sm-4 offset-sm-4 col-4 offset-4 message-animation-single-swap" data-direction="forward" data-sentinel="false" data-swaps="1"></div>

						<div class="col-lg-6 offset-lg-2 col-md-6 offset-md-1 col-sm-12">
							<h3>It's all Relative</h3>

							<p>The important thing to note, for our implementation, is that once we scroll past the first 10 or so, those nodes are hidden by our good friend Mrs. Viewport. Where her wonders work to hide, we can now grab those nodes and move them to the opposite side of the list, effectively extending the list from the scroll position's frame of reference.</p>

							<p>This seems simple enough, but once we move those nodes, assuming they are relatively positioned, the space once occupied reduces to 0, and our overall scroll position is not preserved as expected. The scrollbar is returned to the top of the viewport, and that illusion of a long unending document is lost.</p>
						</div>
					</aside>
					<p>We need a way to scroll down our page, and maintain an actual scroll position as if we had kept all of our messages we've scrolled past. If we don't somehow replace the space lost, we are simply swapping nodes and we never give ourselves a document that grows with each scroll.</p>

					<p>As luck would have it, we do know the height of our swapped messages. Since we're iterating through those swapped blocks of messages, we can also keep track of the overall height lost, and figure out a simple way to keep our document afloat as we scroll further down.</p>
				</section>
				<section class="section-block col-lg-8 col-10 offset-1 offset-lg-2">
					<h2>Sentinels!</h2>

					<aside class="row example-row">
						<figure class="image image-argos col-lg-4 col-md-6 push-md-6 offset-lg-1 col-sm-6 offset-md-0 offset-sm-3 col-12">
							<img src="images/argos.jpg" alt="Greek God Argos">
							<figcaption class="text-center"><i>Argos and Io</i></figcaption>
						</figure>

						<p class="col-lg-6 col-md-6 pull-md-6 offset-lg-1 offset-md-0 col-sm-12 col-12">Where the Greek God Argos guards Io, the white heifer, a sentinel in this context may shepherd our messages as we roam up and down the document. Argos' notable feature was not just one, but a set. Oft described to possess over one hundred eyes, his strength shone in keeping-eye on whatever objects the other Gods saw fit. Luckily, where our programmatic constructs resemble animals, gods, and other objects in the material world—we just need the one metric; our sentinel need only watch for empty space.</p>
					</aside>

					<aside class="row example-row">

						<div class="col-lg-6 offset-lg-0 push-lg-6 col-md-6 offset-md-0 col-sm-12 col-12">
							<h3>Scrolling Down</h3>

							<p>A watchful, obedient program makes for a fine element at the top of our document. As we replace nodes, it's job is to keep track of the overall height of the replaced nodes and occupy any voids created by removed nodes.</p>

							<p> Since the height of any one message can vary—influenced only by the length of the message's content, we sum the height of all messages in the swap operation, and extend our sentinel's height by that amount.</p>

							<p>Each time we swap blocks of nodes, whitespace is preserved, and the document grows naturally—as if it had all previous nodes where they were initially. Our scroll position, from the viewports perspective evolves as we would expect—maintaining the illusion of a long list of DOM elements.</p>
						</div>

						<div class="col-lg-3 pull-lg-6 offset-lg-2 col-md-3 offset-md-2 col-sm-5 offset-sm-4 col-5 offset-4">
							<div class="message-animation" data-direction="forward"></div>
						</div>

					</aside>
					<aside class="row example-row">
						<div class="col-lg-6 offset-lg-0 push-lg-0 push-md-6 col-md-6 offset-md-0 col-sm-12 col-12">
							<h3>Scrolling Up</h3>

							<p>The same can be applied for the opposite direction, this time subtracting the overall height of the  replaced elements from the sentinel.</p>
						</div>

						<div class="col-lg-3 offset-lg-2 pull-lg-0 col-md-3 pull-md-4 offset-md-0 col-sm-5 offset-sm-4 col-5 offset-4" >
							<div class="message-animation" data-direction="reverse"></div>
						</div>
					</aside>

					<p>Surprisingly, that should cover basic scrolling through long lists of messages. With relatively little effort we can shuffle a handful of elements, quite quickly, and with no sight of edges of the smoke and mirrors involved.</p>

				</section>
				<section class="section-block col-lg-8 col-10 offset-1 offset-lg-2">
					<h2>Optimizations and Further Implications</h2>

					<p>The aforementioned cost presents itself to be paid in this section. We're not just scrolling through a long document of infinitely-added elements. We divide a fixed set of elements, introduce states of transition, and rely on correct arithmetic to choreograph our messages to dance in unison. JavaScript, waving its best flag, gives us flexibility and smoothness in its async execution, but that manifests itself in quite the unexpected behaviour.</p>

					<h3>Dynamic Heights</h3>
					<aside class="row example-row">
						<div class="col-lg-6 offset-lg-1 offset-md-3 col-sm-6 offset-sm-3 col-9 offset-3 message-block message-block-dynamic-heights" data-count="3"></div>
						<div class="col-lg-5 col-12 vertically-centered">
							<p> Since we must replace empty space created by removed nodes with each swap operation. We know that our message will be at least some minimum height—with padding, image, name, these values will rarely need to change. What we don't know is how long the content will stretch a single message.</p>

							<p>Where we would never really care about the exact message position and its persistence in a long document of ever-growing nodes, we must know exactly how tall it is to be able to relay that data to our sentinel.</p>
						</div>
					 </aside>
					<aside class="row example-row">
						<div class="col-12">
							<p>The problem evolves when we consider a fluid viewport. Were the viewport to change in width, the available width for message content pushes the messages taller—increasing overall swap heights. Depending where we are in this list, the height we we were tracking will not correspond to an updated height-per-message in the re-sized viewport. So, when we scroll back up, our sentinel height calculations fall out of sync.</p>

							<p>We can guarantee a final <i>zero</i> state for the sentinel's height when we do scroll all the way back, but along the way we may encounter whitespace from the longer-than-expected sentinel.</p>

							<p>Suppose we start with a smaller viewport and scroll our document a few iterations. We resize to a wider viewport and scroll back up. The previously accumulated sentinel height will now be larger per-message since the smaller viewport was skinnier—pushing message content, and by extension, the entire message height. So, when we operate on the new, wider and shorter state, we subtract less than we should from our sentinel.</p>
						</div>
						<div class="row">
							<div class="col-md-5 offset-md-1 col-8 offset-3 message-block" data-count="3"></div>
							<div class="col-md-4 offset-md-2 col-7 offset-3 message-block message-block-dynamic-heights-compare" data-count="3"></div>
						</div>
					 </aside>
					 <aside class="row example-row">
						<div class="col col-lg-12">
							<p>Perhaps there's a clever solution for this edge-case; admittedly, I did not venture a solution for this exercise. Bonus points for a solution!</p>
						</div>
					</aside>

					<h3>Impatient Events Queued into Submission</h3>

					<p>One of the now popular gestures associated with list in web applications is a swipe. This is not new to our daily routines with paper documents, dust on our tables, or bugs in our face. If we do not like something, we swipe it away, out of sight and out of mind. So, when we introduce swiping to our list, we almost certainly think of dismissing a particular message.</p>

					<p>The thought is relatively short-lived in our minds, and our expectation is simply for our wish to be fulfilled. To our program, however, our wish can only be fulfilled by the exact conditions we specify.</p>

					<p>Simple conditionals dictate what we should do with a message when it is swiped. A swipe event meets a minimum threshold, the message moves off-screen, done. Well, not quite. We want to keep the actual DOM element we've removed from view, and replace it with something more meaningful for later viewing. That's fine. We can move the message to end of the list and queue up our next message, from the network, or cache. Still nothing really novel.</p>

					<p>But, suppose we are impatient and swipe several messages from view and quickly scroll up or down in the document.</p>

					<p>In the time, or state, where our messages are being removed from the list, we scroll down, and we tell our program to swap a block of messages from the top, to the bottom. The program must interpret the top most set as 'ready for swap,' yet we could have a swiped message in that set. So, before we've removed and replaced the swiped message, we swap it to the bottom-most position from a competing scroll operation.</p>

					<p>This breaks continuity in most cases, as whichever operation completes first, the following one operates on an outdated state and populates the replaced node with incorrect data.</p>
					<aside class="row example-row">
						<div class="col-lg-6 col-12">
							<p>Where disobedience is settled with order, it's very natural to think in steps of operation, order of importance, or lines of code.</p>

							<p>When we say we <i>queue up</i> a song, we really just wish for it to play, but the mechanism is responsible for fulfilling that request. Similarly, we can assign a set of messages to be swiped and swapped to a Queue function, which will then appropriately shepherd our messages, in-order, and guarantee a swapping, swapped, finished set of states. During those states, we can accumulate another set of requests, swipes, which can be executed once our swipes are completed.</p>
						</div>

						<figure class="image gif queue-gif col-lg-5 offset-lg-1 col-10 offset-1">
							<img src="images/queue.gif" alt="Angry Queue">
							<figcaption class="text-center"><i>An Impatient Bean</i></figcaption>
						</figure>
					</aside>

					<p>The precedence of swipe over scroll can likely be proved trivial, but in practice, the scroll queue never appears to reach more than one operation—likely because we can't scroll that fast, but more importantly, because we shouldn't be able to scroll past an unfulfilled scroll-swap operation to even need another. That would imply that we've reached past the visible nodes of our growing/shrinking document, and would undo what we're trying to build.</p>

					<p>A technical implementation of this queue can be reduced to nothing more than a <code>RequestAnimationFrame</code> loop operating within the scope a few states:</p>
					<aside class="row example-row">
						<div class="col-12">
							<h5>Queue Instance</h5>
							<table class="table">
								<thead>
									<tr>
										<th>Property</th>
										<th>Value</th>
										<th>Usage</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>this.pending</td>
										<td><code>Array</code</td>
										<td>A collection of pending requests to be executed in the order they were added.</td>
									</tr>
									<tr>
										<td>this.isRunning</td>
										<td><code>Boolean</code</td>
										<td>A general state for the queue instance, indicating whether all pending requests have been fulfilled</td>
									</tr>
								</tbody>
							</table>
						</div>
					</aside>
					<p>Each pending request is then constructed of the following:</p>
					<aside class="row example-row">
						<div class="col-12">
							<h5>Request Object</h5>
							<table class="table">
								<thead>
									<tr>
										<th>Property</th>
										<th>Value</th>
										<th>Usage</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>target</td>
										<td><code>Object</code</td>
										<td>The relevant DOM element upon which we are to operate.</td>
									</tr>
									<tr>
										<td>hasFinished</td>
										<td><code>Boolean</code</td>
										<td>A general state for this particular request. Evaluated when previous requests have been fulfilled. Satifisfied when the passed condition is met, or instantaneously if no condition is passed.</td>
									</tr>
									<tr>
										<td>active</td>
										<td><code>Boolean</code</td>
										<td>A general state for the queued operation. Used internally to loop RAF until the condition is met.</td>
									</tr>
									<tr>
										<td>run</td>
										<td><code>Function</code</td>
										<td>Code to be run once our request has been fulfilled.</td>
									</tr>
								</tbody>
							</table>
						</div>
					</aside>
					<p>Subsequently, a function operates on the accumulated requests, in-order, until they are all fulfilled, and the requests array is emptied. So long as our <code>run</code> function takes less than the <code>16ms</code> it should take for a <code>RequestAnimationFrame</code> to complete before the next RAF is called, we should be able to maintain strong synchronization among our draws, swaps, scrolls, and swipes.</p>

					<p>So, with a queue instantiated for each distinct action, scroll and swipe, if we have a running swipe queue, we hold off on replacing DOM nodes for a scroll event that may be requested. We fulfill the scroll request <i>after</i> the swipe operation has settled our recently swapped/replaced DOM element, and allow it to operate on the most current state. This appears to happen fast enough for a practical amount of swiped messages. It can likely be broken, but likely not at the speed with which normal fingers can operate.</p>

					<h3>Network Optimizations:</h3>
					<aside class="row example-row">
						<figure class="image gif latency-gif col-lg-5 col-md-5 offset-md-0 col-10 offset-1">
							<img src="images/latency.gif" alt="“ Oh dear ! Oh dear ! I shall be too late!">
						</figure>

						<p class="col-md-7 col-12">We don't need all the messages at once. That's fine, most applications have solved this problem in a thousand different flavors. Pagination, gestures, push notifications, and the like adhere to a common operating principle—reduce server fetches to conserve data, avoid unnecessary calls to keep traffic down, and spare the user of data she cannot see or would otherwise need not directly engage.</p>
					</aside>

					<p>Since our presentation of messages, <i>under-the-hood</i>, is more akin to pagination, we can leverage our dynamic calls for new messages in at least these fashions:</p>
					<ul>
						<li>We're already looping through our messages, so we can push to an array with message contents and any other meaningful attributes about it—replacing said info from the cached array on subsequent swaps. So, in the same operation, we simply check to see if the message is already available, and populate data from the cache, rather than sending off another XHR.</li>

						<li>We can extend the reach and power of our cache to utilise robust search by relying on cached data, rather than server-side look-ups. So, where a robust lookup may take longer to fulfill, a similar algorithm can be executed clientside with the already-available data. <i>Whether this is actually true becomes evident in future iterations of a tool like our dynamic list</i>.</li>
					</ul>

					<p>The above satisfy server load concerns, but what about user experiences in slow-internet conditions. The state of mobile Internet in the very country that invented it can be—slow. At least for our scope, a set of messages is usually a very small amount of data. However, user avatars, gifs, images, and other engaging content can amount to more expense.</p>

					<h3>Tombstones over Spinners!</h3>
					<aside class="row example-row">
						<p class="col-md-7 col-12">There are a few, yet frequent enough to mention, use cases where we pull up a chat stream and recall a certain message. It must have been created a few days ago, so we know to scroll back to around 50-100 messages. Our Internet fails to deliver messages as fast as we can scroll back, so we have nothing to show and we whip up a spinner, reducing any parallelism in how the user may want to navigate the list.</p>

						<figure class="image gif fetch-spinner-gif col-md-5 offset-md-0 col-9 offset-1">
							<img src="images/fetch-spinner.gif" alt="Fetch!">
							<figcaption class="text-center"><i>There is no "Spin" </i></figcaption>
						</figure>
					</aside>
					<aside class="row example-row">
						<p class="col-12">Nonsense! From memory, we know our message will all share at least form, and some recyclable elements. We can generalize a message to look a bit like this:</p>

						<div class="col-md-5 offset-md-0 col-10 offset-1">
							<div class="tombstone-stack" data-count='3'></div>
						</div>

						<p class="col-md-7 col-12 vertically-centered">An avatar here, some date/time info there, and a bit of content to sew it all up. Let's show that and maintain the scrolling experience in the meantime. Our intention is to scroll back to a few days, not to wait however long it takes for the server to retrieve a set of messages, before continuing further a long the list.</p>
					</aside>


					<p>Furthermore, the whizzing motion of the tombstone demonstrates motion in general—exactly what a spinner is meant to accomplish. Where the latter is simply a visual cue that some request is being fulfilled, the former is interactive and can delegate multiple requests, with more granularity to changes in direction, speed, and precision.</p>

					<p>This construct not only maintains continuity in the visual sensation we get from scrolling, but also allows for a more robust search when those messages finally resolve to data. Where the former allows the user to actually associate their actions with instantaneous feedback of a scrolling list of elements, the latter opens up possibilities in search that are often ill-represented in search/filter applications.</p>

					<p>When we search our list, we usually recall a few words, and hope to find those words in a message we or someone else mentioned in the last couple days. So instead of waiting for a single set to be retrieved, we retrieve several sets with a continuous gesture, and then go <i>jazz-hands</i> on the search bar. In fact, this style of <i>fetch a bunch—search when done</i> dynamic can allow us to quickly realize what it is we want from the list. The eventual search operation can then programmatically scroll us right over to the message(s) we are hoping to find.</p>

					<p>These are simply ideas for the direction a project like this would go; After some thought, implementing tombstones by resolving a <code>Promise</code> bound to some DOM element is likely just the simple case. Were we to scroll past a few swap operations, the node to which we would resolve our data would already have been swapped and may be in a different place entirely. We would need more logic to dismiss the promised data and populate from the relevant request. That is not to say this is impossible!</p>

				</section>
			</article>
		</section>
		<section class="container-fluid introduce-main-demo">
			<header class="row">
				<div class="section-block col-lg-8 col-10 offset-1 offset-lg-2">
					<h2>All Together Now!</h2>

					<p>Below you'll find the full implementation of this little dance of DOM elements. Be sure to try and break it, scrolling as fast as possible and swiping to dismiss messages all at once! Pulling up dev tools will reveal how things are being swapped. Source code, and suggestions are welcome on GitHub can be found <a href="#">here.</a></p>

					<p>I am confident that there is efficiency to be brought to long-document scrolling experiences. This may be exotic, or not exotic enough, to actually leverage the best possible performance and usability, but I do believe it helps to re-frame classic constructs in our documents.</p>

					<p>Have fun and be sure to suggest improvements, question the efficacy of all this swap-nonsense, and anything else that comes to mind!</p>

				</div>
			</header>
		</section>

		<section class="container-fluid">
			<div class="row">
				<div id="message-stream" class="col-12 messages-wrapper">
					 <div class="navbar-container ">
						<nav class="navbar navbar-light">
							<button class="navbar-toggler navbar-toggler-left" type="button">
								<span class="navbar-toggler-icon navbar-element"></span>
							</button>
							<span id="messages-title" class=" navbar-element navbar-brand">Messages</span>
						</nav>
					</div>
					<div id="sentinel" class="sentinel"></div>
				</div>
			</div>
		</section>
		<section id="debug-panel" class="debug-panel vertically-centered">
			<div class="backdrop"></div>
			<span>Automated Scroll!</span><br>
			<div class="row">
				<button class="scroll btn btn-small up">down</button>
				<button class="scroll btn btn-small down">up</button>
			</div>

		</section>
	</main>
	<!-- vendor -->
	<script src="lib/hammer.min.js"></script>

	<!-- helpers -->
	<script src="js/Utils.js"></script>
	<script src="lib/StaticDataServer.js"></script>

	<!-- components -->
	<script src="js/components/queue.js"></script>
	<script src="js/components/Message.js"></script>
	<script src="js/components/TombstoneStackComponent.js"></script>
	<script src="js/components/MessageBlockComponent.js"></script>
	<script src="js/components/MessageStreamComponent.js"></script>
	<script src="js/components/AnimatedMessageComponent.js"></script>

	<script src="js/main.js"></script>
</body>
</html>
